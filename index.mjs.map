{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isnan from '@stdlib/math-base-assert-is-nan';\nimport SIGN_MASK from '@stdlib/constants-float16-sign-mask';\nimport UINT16_MAX from '@stdlib/constants-uint16-max';\nimport toWord from '@stdlib/number-float16-base-to-word';\nimport abs from '@stdlib/math-base-special-abs';\n\n\n// FUNCTIONS //\n\n/**\n* Converts an unsigned 16-bit integer corresponding to the IEEE 754 binary representation of a half-precision floating-point number to a lexicographically ordered integer.\n*\n* @private\n* @param {unsigned16} word - unsigned 16-bit integer\n* @returns {integer} lexicographically ordered integer\n*/\nfunction monotoneKey( word ) {\n\tif ( word & SIGN_MASK ) { // x < 0\n\t\treturn ( ( ~word + 1 ) & UINT16_MAX ); // two's-complement negation\n\t}\n\t// x >= 0\n\treturn ( word | SIGN_MASK ) >>> 0; // push +0 to just above -0\n}\n\n\n// MAIN //\n\n/**\n* Computes the number of representable half-precision floating-point values that separate two half-precision floating-point numbers along the real number line.\n*\n* ## Notes\n*\n* -   Adjacent half-precision floating-point numbers differ by 1 ulp (unit in the last place).\n* -   Signed zeros differ only in the sign bit but are considered numerically equal, and thus their ULP difference is 0.\n*\n* @param {number} x - first value\n* @param {number} y - second value\n* @returns {number} result\n*\n* @example\n* import EPS from '@stdlib/constants-float16-eps';\n*\n* var d = ulpdiff( 1.0, 1.0+EPS );\n* // returns 1.0\n*\n* d = ulpdiff( 1.0+EPS, 1.0 );\n* // returns 1.0\n*\n* d = ulpdiff( 1.0, 1.0+EPS+EPS );\n* // returns 2.0\n*\n* d = ulpdiff( 1.0, NaN );\n* // returns NaN\n*\n* d = ulpdiff( NaN, 1.0 );\n* // returns NaN\n*\n* d = ulpdiff( NaN, NaN );\n* // returns NaN\n*/\nfunction ulpdiff( x, y ) {\n\tvar wx;\n\tvar wy;\n\n\tif ( isnan( x ) || isnan( y ) ) {\n\t\treturn NaN;\n\t}\n\t// Convert input values to unsigned 16-bit integers corresponding to the IEEE 754 binary representation of half-precision floating-point numbers:\n\twx = toWord( x );\n\twy = toWord( y );\n\n\t// Convert the words to lexicographically ordered integers:\n\twx = monotoneKey( wx );\n\twy = monotoneKey( wy );\n\n\t// Return a double as a result, which can exactly represent the ULP difference for all representable half-precision floating-point numbers:\n\treturn abs( wx - wy );\n}\n\n\n// EXPORTS //\n\nexport default ulpdiff;\n"],"names":["monotoneKey","word","SIGN_MASK","UINT16_MAX","ulpdiff","x","y","wx","wy","isnan","NaN","toWord","abs"],"mappings":";;seAsCA,SAASA,EAAaC,GACrB,OAAKA,EAAOC,EACQ,GAAPD,EAAaE,GAGjBF,EAAOC,KAAgB,CACjC,CAsCA,SAASE,EAASC,EAAGC,GACpB,IAAIC,EACAC,EAEJ,OAAKC,EAAOJ,IAAOI,EAAOH,GAClBI,KAGRH,EAAKI,EAAQN,GACbG,EAAKG,EAAQL,GAGbC,EAAKP,EAAaO,GAClBC,EAAKR,EAAaQ,GAGXI,EAAKL,EAAKC,GAClB"}